<!-- -*- coding: utf-8 -*- -->
<span id="slides-title" hidden>Аифметические схемы, плексоры, память, ПЛИС</span>

Арифметико-логическое устройство
=========================

Точнее, на данной лекции, арифметическое

- - - - - -

## Устройство и действие сумматора

* **Сумматор** (**Adder**) — логическая схема, получающая на входе биты слагаемых и выдающая биты их суммы

Складываем $A+B=S$.

При суммировании двоичных чисел у $i$-го разряда

* на вход поступают
$a_i, b_i, c_{i-1 \rightarrow i}$
* на выходе имеем: $s_i, c_{i \rightarrow i+1}$

При этом:

* $s_i = a_i \oplus b_i \oplus c_{i-1 \rightarrow i}$
* $c_{i \rightarrow i+1} = (a_i \land b_i) \lor (b_i \land c_{i-1 \rightarrow i}) \lor (c_{i-1 \rightarrow i} \land a_i)$

Таким образом, сумматор --- логическая схема.

- - - - - -

## Схема 1-разрядного сумматора

### 1-разрядный полусумматор

Полусумматор (2 входа)

* $s = a \oplus b$
* $c = a \wedge b$

### 1-разрядный полный сумматор

* Оптимизируем формулу для переноса с предыдущего слайда:

$$c_{i \rightarrow i+1} = (a_i \land b_i) \lor (c_{i-1 \rightarrow i} \land (a_i \oplus b_i))$$

* Это позволит создать 1-битный сумматор на основе двух полусумматоров и ещё 1 вентиля
  * на самом деле входы равноправны

- - - - - -

## Схема многоразрядного сумматора

* Собирается через соединение переносов
* Узкое место по времени --- как раз перенос

- - - - - -

## Многоразрядный сумматор: замечания

Перенос через сумматор распространяется постепенно, поэтому:

* в старших разряде «ответ» есть сразу, но он неправильный
* правильный ответ появляется через какое-то время
* чем больше разрядность операции, тем больше время, даже для одного и того же процессора

Последний бит переноса $c_{N-1 \rightarrow}$ можно запомнить и при следующем суммировании использовать в качестве $c_{\rightarrow 0}$. Это позволит соединить
несколько сумматоров или несколько раз использовать один и тот же для реализации арифметики произвольной разрядности.


- - - - - -

## Оптимизация: упреждающий сегментированный сумматор I

<div style="text-align: center;">

![image](images/12.lookahead-adder.svg) <!--.element: style="width: 80%;" -->

</div>


- - - - - -

## Оптимизация: упреждающий сегментированный сумматор II

-   (?) --- мультиплексор (ниже)
-   Вынашивание полутора детей за 4,5 месяца. Да, можно!
-   Можно сделать 3, 4 или больше сегментов
-   Важна золотая середина: сегменты выбираются последовательно
    $\Rightarrow$ грубая оценка --- порядка $\sqrt{N}$ (на самом деле
    меньше)

- - - - - -

## Инвертор (для вычитания)

$x-y = x+(-y)$. Проблема --- вычислить $-y$, зная $y$.

$[-y] = [P-y] = [P-1+1 - y] = [1] + [(P-1) - y]$ --- уже легче, осталось вычислить $(P-1) - y$ (а сумматор, только прибавляющий 1, можно дополнительно оптимизировать)

Для $P = 2^N$ справедливо $P-1 = \displaystyle\sum_{i=0}^{N-1}2^i$.

Т.е. это число со всеми двоичными единицами. Чтобы вычесть из него $y$,
достаточно инвертировать все биты $y$ при помощи вентиля НЕ, т.к. заёма при вычитании не возникает

- - - - - -

## Умножение и деление: Мультипликатор

При умножении на 1 бит числа $x$ мы можем пользоваться логической
схемой:

$$x\times b = x \land b.$$

Тогда для многоразрядных чисел справедливо ($\ll$ --- операция сдвига):

$$x \times y = \sum_{i=0}^{N-1} (y_i \land (x\ll i))$$

Т.е. выразили умножение через известные операции.

Разрядность произведения --- сумма разрядностей множителей.

- - - - - -

## Умножение и деление: Делитель

Алгоритм деления «в столбик» для системы счисления с произвольным
основанием:

1.  сдвигаем делитель влево, пока он меньше делимого;

2.  вычитаем, пока вычитается, прибавляя к очередному разряду частного;

3.  сдвигаем делитель вправо (и меняем позицию в частном), пока нельзя
    вычитать, потом (2);

4.  если делитель вернулся на исходную позицию относительно сдвига, то
    от делимого остался остаток.

Для двоичной:

-   вычитаем, **если** *(а не пока)* вычитается.

@pause@

Деление медленное, многие компиляторы умеют заменять деление на константу умножением, пользуясь свойствами кольца $\mathbb{Z}/{2^{64}}$ (для 64-битных машин). Например, `a / 7` компилируется для x86\_64 в `imul   rcx,rax,0xffffffff92492493`

- - - - - -

## Умножение и деление: замечания

-   Мультипликатор, как и сумматор, можно реализовать логической схемой,
    но очень громоздкой, поэтому часто его делают микропрограммой. А на
    простых архитектурах --- программой.

-   Есть аппаратные логические делители --- большие и «горячие»
    микросхемы, используются очень редко. Делитель --- почти всегда
    микропрограмма (или программа).

-   Умножение чисел произвольной длины возможно, однако перенос
    эффективнее делать по слову (старшей половине произведения), а не по
    биту.

= = = = = = =

(Де)шифраторы и плексоры
=======================

- - - - - -

## Шифратор и дешифратор

* **Шифратор** (**encoder**) — логическая схема, выдающая в двоичном виде номер активного (того, на котором 1) входа
* **Дешифратор** (**decoder**) — логическая схема, выдающая 1 на выход, заданный номером в двоичном виде



* С криптографией не связаны =)

- - - - - -

Мультиплексор и демультиплексор
-----------------

<div style="text-align: center;">

![image](images/12.mux_demux.svg) <!--.element: style="width: 80%;" -->

</div>

- - - - - -

## Использование и неиспользование (де)мультиплексоров

## Теле-$\ldots$ связь

### Системы упаковки и свёртки/развёртки

-   Красным --- сигнальные линии, м.б. аналоговые, м.б. многобитные.

-   В I половине XX века для временнóго мультиплексирования телефонных
    линий применялись ламповые (де)мультиплексоры.

-   Не в чистом виде

    -   Фототелеграф (см. М. Булгаков, Мастер и Маргарита).

    -   Современный (не в чистом виде) вариант: аналоговая телекамера
        $\rightarrow$ телевизор с ЭЛТ.

= = = = = = =

# DRAM

<div style="text-align: center;">

![image](images/12.dram.svg) <!--.element: style="width: 80%;" -->

</div>

Технологически конденсатор выполняется вместе с транзистором и почти не
требует дополнительного места (может быть использована ёмкость P-N
перехода).

- - - - - -

## [Чарлиплексор](http://en.wikipedia.org/wiki/Charlieplexing)

<div style="text-align: center;">

![image](images/12.charlieplex.svg) <!--.element: style="width: 80%;" -->

</div>

$2{\binom n 2} = 2 \mathrm{C}^n_2 = \frac{n!}{(n-2)!2!}$ комбинаций на $n$ входах. Используется свойство светодиодов открывать одну самую короткую из параллельных цепей.

- - - - - -

Flash-память: элементная база
------------

* [Униполярный транзистор](http://en.wikipedia.org/wiki/Field_effect_transistor)

@pause@

* [Транзистор с плавающим затвором](http://en.wikipedia.org/wiki/Floating-gate_transistor)
Эти транзисторы могут при подаче *достаточно* высокого или *достаточно* низкого потенциалов (т.е. заметно больше 1 или заметно меньше 0) на управляющий вход запоминать своё состояние. После нескольких миллионов срабатываний транзистор необратимо портится (поэтому у Flash ограничено количество перезаписей). Этим эффектом, так
же, как и широкой петлёй гистерезиса (хотя природа этого совершенно иная), можно пользоваться для хранения данных.

* На основе таких транзисторов делается [флэш-память](http://en.wikipedia.org/wiki/Flash_memory)

- - - - - -

## Flash-память: реализация NAND

<div style="text-align: center;">

![image](images/12.nand.svg) <!--.element: style="width: 60%;" -->
</div>

* Для чтения на все слова, кроме читаемого, подаётся небольшой «приоткрывающий» потенциал. Ток течёт с соответствующих открытым транзисторам битовых линий в землю.
* Для программирования (открытия затвора, установки в бита 0) надо небольшим потенциалом «приоткрыть» все линии слов и подать сильный сигнал на пересечения нужных слова и бита.

- - - - - -

Flash-память: особенности NAND, альтернативы
------------

* Из-за особенностей изготовления танзисторов, cброс (в 1) по словам или ещё большим блокам
* Для SSD введена операция [`TRIM`](https://ru.wikipedia.org/wiki/TRIM), которая говорит накопителю, что блок памяти свободен и может использоваться для оптимизации с целью увеличения ресурса перезаписи

@pause@

* Альтернативная технология — [память на основе изменений фазового состояния халькогенидов](https://en.wikipedia.org/wiki/Phase-change_memory#Challenges) — обладает потенциально лучшими характеристиками, уже используется коммерчески (Например, кэш для ФС Intel Optane™), но тоже со временем деградирует

= = = = = =

# ПЛИС

- - - - - -

## Что это и зачем?

Что это?

* **Программируемые логические интегральные схемы** (**Programmable Logic Device**) — интегральные схемы, физический уровень которых (реализующий логику) можно задавать программно
  * программируются связи между компонентами схемы

Зачем?

* Применяются для эффективной реализации (быстродействие — заметно медленее серийных микросхем, существенно быстрее микропрограмм, принципиально быстрее обычной программной реализации) специфических задач
    * прототипирование, единичное или мелкосерийное производство
    * микропроцессоры встроенных ЭВМ

- - - - - -

## Какие бывают ПЛИС?

* Простые ПЛИС — логические функции, в т.ч. довольно сложная логика, но явно задаются через вентили «и», «или», «не»
* CPLD (Сomplex Programmable Logic Device) — несколько более высокоуровневые, содержат внутренние шины, более сложные элементы
* Программируемая пользователем вентильная матрица (Field-Programmable Gate Array, FPGA) — содержит готовые регистры, компоненты АЛУ и т.д.

- - - - - -

## Пример: ПЛИС типа GAL (Gateway Array Logic)

<div style="float: left; width: 45%;">

![image](images/12.PLD.svg) <!--.element: style="width: 100%;" -->
</div>

<div style="float: right; width: 55%;">

* Схема на примере вычислаяет функции, представленные в ДНФ:
  * $F_0 = B \wedge\neg C \vee A\wedge C$
  * $F_1 = B \wedge\neg C \vee \neg A \wedge \neg B$
  * $F_2 = A\wedge C \vee \neg A \wedge B$
* Входов у вентилей обычно больше
* Как реализуются перемычки в полях OR и AND?
  * «пережиганием» (одноразовое программирование)
  * мультиплексором с управлением статической памятью (на основе D-триггера, будет позже)
  * транзистором с плавающим затвором
</div>

- - - - - -

## Как программировать ПЛИС и чего можно добиться?

* Специальные языки, например Verilog Hardware Definition Language
* САПР (даже Logism)
  * Т.е. почти всё, что есть (было и будет) в данном курсе, можно сделать на ПЛИС
* **Hardware-Software CoDesign** — подход, подразумевающий совместную разработку специализированных ПО и оборудования
  * На кафедре системного программирования СПбГУ — Булычев, Медведев, Терехов: https://scholar.google.com/scholar?q=HasCOL+SPbU

= = = = = =

## Вопросы

* Что такое сумматор? Что такое полусумматор?
* Как реализуется полный многоразрядный сумматор?
* Как можно оптимизировать перенос в многоразрядном сумматоре?
* Как устроены вычитатели, умножители, делители?
* Что такое ширатор и дешифратор?
* Что такое мультиплексор и демультиплексор?
* На каком принципе основан и для чего используется Чарлиплексор?
* Как организована динамическая память?
* Как организована NAND-память?
* Что такое ПЛИС? Зачем они нужны и какие бывают?
* Опишите структуру ПЛИС типа GAL с полями AND и OR
* Как программируются ПЛИС?
