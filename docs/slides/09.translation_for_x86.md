<!-- -*- coding: utf-8 -*- -->
<span id="slides-title" hidden>Трансляция программ на примере Intel x86</span>

# Архитектура и набор команд x86

- - - - - -

## Регистровый файл (1)

Регистры (для 32-битной ЭВМ)

- EAX (общий, аккумулятор), EDX (умножение и деление вместе с EAX), EBX (указатели), ECX (счетчик)
- EDI (dest index), ESI (source index)
- EBP, ESP, EIP
- CS, SS, DS, ES, FS, GS — сегментные
- EFLAGS

@pause@

Фрагменты регистров

* \_H, \_L — 8-разрядные
* \_X, \_S — 16-разрядные
* E\_ — 32-разрядные
* R\_ — 64-разрядные

Напрмер, для аккумулятора

AH (8), AL (8) → AX (16) → EAX (32) → RAX (64)

- - - - - -

## Регистровый файл (2)

### EFLAGS

Весь регистр 32-битный (начиная с 80386).

Основные флаги (с 8086):

-   OF — флаг переполнения
-   DF — флаг направления
-   IF — флаг прерывания
-   TF — флаг трассировки
-   SF — флаг знака
-   ZF — флаг нуля
-   AF — флаг дополнительного переноса (для упакованных
    двоично-десятичных операций)
-   PF — флаг четности
-   CF — флаг переноса

- - - - - -

Система адресации данных
========================

-   Непосредственная (аргументы в коде)

-   Регистровая (номер регистра в коде)

-   Память\[E\_X + смещение\], Память\[EBP + смещение\], + возможно
    префиксы сегментов

- - - - - -

Система команд
==============

Команды пересылки данных 
------------------------

- MOV память обменивается только с арифметическими регистрами, ESI, EDI
- XCHG reg, mem/reg
- LAHF, SAHF — флаги $\leftrightarrow$ AH

- - - - - -

Команды АЛУ
-----------

### Логические

AND, OR, XOR, NOT

### Арифметические

-   ADD, SUB, ADC, SBB, INC, DEC, NEG

-   MUL (reg/mem), DIV (reg/mem), IMUL, IDIV,

-   CWQ (EAX $\rightarrow$ EDX:EAX)

### Сдвига

-   ROR, ROL

-   RCL, RCR — с переносом

-   SHL, SHR — без переноса

-   SAL, SAR — со знаковыми битами

- - - - - -

## BCD

ASCII и BCD — для быстрого преобразования двоично-десятичных чисел

- - - - - -

Команды работы со стеком 
------------------------

-   PUSH, POP

-   PUSHA, POPA

-   Косвенно — CALL, RET, INT, IRET

- - - - - -

Команды сравнения и передачи управления 
---------------------------------------

### Переходы Безусловные

-   JMP FAR, NEAR, JMP M\[xx\], JMP REG

- - - - - -

## Команды Сравнения

-   CMP — как SUB

-   TEST — как AND

-   CMPS — CMPSB, CMPSW, CMPSD

@pause@

### Compare-exchange

-   CMPXCHG dest, src — Сравнивает аккумулятор (8-64 bits) с dest.
    Если равны, то в dest грузят src, иначе в аккумулятор загружают
    dest

@pause@

Ужас. Кошмар. [Для чего она?..](https://ru.wikipedia.org/wiki/%D0%A1%D1%80%D0%B0%D0%B2%D0%BD%D0%B5%D0%BD%D0%B8%D0%B5_%D1%81_%D0%BE%D0%B1%D0%BC%D0%B5%D0%BD%D0%BE%D0%BC#%D0%97%D0%B0%D1%87%D0%B5%D0%BC_%D1%8D%D1%82%D0%BE_%D0%BD%D1%83%D0%B6%D0%BD%D0%BE)


- - - - - -

## Условные переходы I

По результату $R$ или итогам сравнения $A ? B$, в зависимости от
получившихся значений флагов.


Беззнаковые

-   JA/JNBE — если $A > B$;
-   JAE/JNB/JNC — если $A \ge B$;
-   JB/JNAE/JC — если $A < B$;
-   JBE/JNA — если $A \le B$.

Знаковые


-   JG/JNLE — если $A > B$;
-   JGE/JNL — если $A \ge B$;
-   JL/JNGE — если $A < B$;
-   JLE/JNG — если $A \le B$;
-   JNS — если $R\ge 0$;
-   JS — если $R<0$.

- - - - - -

## Условные переходы II

По результату $R$ или итогам сравнения $A ? B$, в зависимости от
получившихся значений флагов.

-   JE/JZ — если $A=B \lor R = 0$;

-   JNE/JNZ — если $A \not = B \lor R \not = 0$;

-   JNO — $\neg OF$;

-   JO — $OF$;

-   JCXZ — $CX = 0$ — для организации циклов\
    `do ... while(--CX);`;

-   JNP/JPO — $\neg PF$;

-   JP/JPE — $PF$.

- - - - - -

## Вызовы и прерывания

- Вызовы
  - CALL адрес
- Прерывания
  - Управление STI, CLI
  - Ожидание (HALT)

- - - - - -


## Команды ввода-вывода

IN (mem/DX), OUT (mem/DX) — с AL

- - - - - -

## Команды обработки строк (микроциклы)

-   REP, REPE, REPZ, REPNE, REPNZ

-   LODS (загружает в аккумулятор),\
    STOS (пишет из аккумулятора),\
    MOVS (B-W-D — пересылка память-память),\
    CMPS(сравнение память-память),\
    SCAS (вычитает из аккумулятора)

@pause@

Команды учитывают DF — флаг направления. Выставив его «неправильно» можно быстро размножить участок памяти

- - - - - -

## Команды математического сопроцессора

Сопроцессор стековый

-  загрузить из памяти / выгрузить в память, формат
-  загрузить из регистра целое / выгрузить в регистр целое
-  операции и функции
-  дублирование / стирание вершины
-  FWAIT

- - - - - -

## Команды управления защитой

Загрузка таблиц страниц и дескрипторов, изменение режимов работы процессора

= = = = = =

# Трансляция программ

- - - - - -


* Таненбаум Эндрю С, Бос Херберт. **Современные операционные системы**. 4-е изд. Издательский дом "Питер", 2018 г. 1120 с.
   * Устройство мира согласно языку C

- - - - - -

Машинно-независимые стадии работы транслятора
--------------------------

- - - - - -

### Опциональная стадия: Препроцессирование

-   На входе — исходный код
-   На выходе — подмножество входного языка, понимаемое без
    сопроцессора + некоторая информация об исходных координатах
    сгенерированного кода

Иногда оптимизируется при помощи precompiled headers

- - - - - -

### Стадия: Лексический анализ

На входе — код на языке, на выходе — последовательность лексем,
включающая:

- текстовое представление
- класс лексемы (константа, идентификатор, конкретное ключевое слово)
- предметное значение лексемы

Лексический анализатор может быть реализован, как сопроцедура

- - - - - -

### Стадия: Синтаксический анализ

- На входе — последовательность лексем.

- На выходе — дерево с перекрестными ссылками и вспомогательными
  таблицами (после идентификации).

- - - - - -

### Замечание

Лексические и синтаксические анализаторы сейчас обычно генерируются по специальным наборам правил — [формальным грамматикам](https://ru.wikipedia.org/wiki/%D0%A4%D0%BE%D1%80%D0%BC%D0%B0%D0%BB%D1%8C%D0%BD%D0%B0%D1%8F_%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B0%D1%82%D0%B8%D0%BA%D0%B0#%D0%9F%D1%80%D0%B8%D0%BC%D0%B5%D1%80_%E2%80%94_%D0%B0%D1%80%D0%B8%D1%84%D0%BC%D0%B5%D1%82%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B5_%D0%B2%D1%8B%D1%80%D0%B0%D0%B6%D0%B5%D0%BD%D0%B8%D1%8F)

- - - - - -

### Опциональная стадия: Претрансляция

Как макросы, но для синтаксического дерева, а не для исходного кода

- На входе дерево.
- На выходе дерево, в котором конструкции, определенные пользователем, транслированы в стандартные конструкции языка.

@pause@

Типичные применения:

* Дополнение языка новыми конструкциями
* Сужение «ядра» языка при помощи выражения части конструкций через другие

[Пример для языка Julia](https://docs.julialang.org/en/v1/manual/metaprogramming/#Hygiene-1)

- - - - - -

### Опциональная стадия: Машинно-независимые оптимизации

-   Константные вычисления
-   Общие подвыражения
-   Недостижимый код
-   Раскрутка и итерация циклов
-   Встраивание тел процедур

- - - - - -

Машинно-зависимые стадии
------------------------

- - - - - -

### Генерация ассемблера

Машинно-зависимые оптимизации

-   Расположение данных в структурах

-   Распознавание образцов синтаксического дерева снизу вверх

Генерация

-   Распознавание образцов ассемблера

-   Распараллеливание работы с сопроцессорами

-   Полные раскрутка и сокращение переходов

- - - - - -

### Ассемблирование

Генерация машинного кода с частично неразрешенными метками

- - - - - -

### Связывание

-   Подсчет объема блоков кода и разрешение меток

- - - - - -

### Исполнение

-   Загрузка и инициализация

- - - - - -

### Динамическое связывание

-   Загрузка и инициализация

-   Разрешение внешних динамических меток

- - - - - -

Всё вместе
----------

<div style="text-align: center;">

![](images/09.translation.g.svg) <!--.element: style="width: 80%;" -->

</div>

- - - - - -

Пример трансляции программы (1)
----------------------------------

```
#include <stdio.h>

double ipow(int pow, double base)
{
    double res = 1, tmp = base;
    while(pow)
    {
        if(pow & 1)
            res *= tmp;
        tmp *= tmp;
        pow >>= 1;
    }
    return res;
}
int main()
{
    printf("%f\n", ipow(5, 3.14159265358979323846));
    return 0;
}
```

- - - - - -

Пример трансляции программы (2)
----------------------------------

* Visual C++ `cl -Od -c -Fa -FAs ipow.c `
* GCC `gcc -S -c -fverbose-asm -O0 -masm=intel ipow.c `
* https://godbolt.org/

@pause@

- Попробуйте `-O3` для GCC и `-Ox` для VC на x86\_64 и посмотрите, как изменился протокол вызова и код

- - - - - -

## Вопросы

1. TODO

## Упражнения

1. Попробуйте воспользоваться претрансляцией для любого языка (Scheme, Julia, Nemerle, ...)
2. Скомпилируйте программу из примера для любой незнакомой архитектуры; пользуясь справочниками, объясните действия всех машинных команд
