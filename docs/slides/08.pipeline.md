<!-- -*- coding: utf-8 -*- -->
<span id="slides-title" hidden>Вычислительный конвейер</span>

# Вычислительный конвейер

- - - - - -

## Снова немного про CISC и RISC

* 1960-е — CISC
  * много сложных и умных команд, дружественный машинный язык (и ассемблер)
  * разработка ПО на фоне общей цены IT-проектов сравнительно недорого
* 1980-е — RISC
  * команды более простые и глупые, недружественный машинный язык (и ассемблер)
  * разработка ПО в IT-проектах — значительная часть бюджета
  * где логика?..

@pause@

В 1970-х – 80-х массовая разработка на языках высокого уровня, поэтому «страдает» не программист, а компилятор

@pause@

А ещё машинный код RISC по объёму больше в полтора–два раза. Но и память в 1980-х уже не настолько дорогая.

- - - - - -

## Пример без конвейера

Команда сложения числа из регистра с числом из памяти `add eax, DWORD PTR [ebp-0x8]` в процессоре Intel 80386

1. выполняется чтение числа из регистра `eax`
2. выполняется чтение значения адресного регистра `ebp`
3. вычисляется адрес в памяти для второго операнда
4. выполняется чтение по этому адресу числа из памяти
5. выполняется сложение двух чисел
6. результат записывается в регистр `eax`

При этом

* Вся команда выполняется за 6 тактов
  * на самом деле это совпадение: не все перечисленные операции выполняются за один такт, но некоторые могут перекрываться по времени
* На каждом такте задействуется лишь часть блоков процессора, а остальные простаивают
  * например, в момент сложения полученного из памяти числа со значением в регистре `eax` блок работы с памятью простаивает

- - - - - -

## Распараллеливание: путь к конвейеру

* Эли Уитни, 1798 (оружейное производство) — одновременное изготовление стандартизованных узлов мушкета разными рабочими, затем быстрая сборка готовых изделий
* Генри Форд, 1913 и т.д. — сборка электрогенераторов, затем моторов и целых автомобилей
  * Разные этапы производства выполняются разными рабочими
  * Рабочие работают одновременно, каждый на своём этапе
* Конвейер в системе образования
  * Школа: 1–11 классы — выпуск каждый год, но школьник учится 11 лет
  * Высшее образование: старая поговорка — *Матмех — не школа, за 10 лет не окончишь* =)
* Конвейер в менеджменте
  * Конвейерное исполнение заказов

- - - - - -

## Недостатки конвейера

* Низкая гибкость — организованный и запущенный конвейер тяжело приспособить к изменяющейся ситуации
* Снижение качества результата в угоду массовости
  * Пример: товар есть на складе в моём городе, но почему-то едет с другого конца страны

Выходы:

* В менеджменте это преодолевается переходом от конвейера к организации бизнес-процессов — сложнее, но адаптивнее

= = = = = =

# Вычислительный конвейер

- - - - - -

## Пример: Classic RISC Pipeline (1)

(Wikipedia)

<div style="text-align: center;">

![](images/08.classic-RISC-pipeline.png) <!--.element: style="width: 80%;" -->

</div>

Стадии:

1. IF (instruction fetch) — получение инструкции
2. ID (instruction decode) — раскодирование инструкции
3. EX (execute) — выполнение инструкции
4. MEM memory access) — доступ к памяти
5. WB (register write back) — запись в регистр

- - - - - -

## Пример: Classic RISC Pipeline (2)

Что даёт конвейеризация?

* Скорость выполнения отдельных команд
  * Каждая команда выполняется за 5 тактов как с конвейером, так и без
  * В отношении одной команды на разных тактах задействованы разные блоки
* Скорость выполнения программы
  * На каждом такте завершается очередная команда
  * Конвейеризация ускоряет работу программы в 5 раз (в данном примере), все блоки задействованы всё время

@pause@

Косвенная выгода: «сосредоточение» отдельных стадий в компактных блоках позволяет увеличить тактовую частоту

- - - - - -

## Что же такое конвейер?

**Вычислительный конвейер** — механизм распараллеливания выполнения машинных команд, позволяющий оптимально задействовать блоки процессора путём разбиения команд на стадии и распределения стадий по блокам

@pause@

Конвейеры появились в 1950-х годах, термин «конвейер» (pipeline) ввёл конструктор советских ЭВМ С.А. Лебедев.

Синонимы: *водопровод*, английский термин — *pipeline*

- - - - - -

## Проблемы конвейеризации

1. Конфликты по данным между зависимыми машинными командами, например: 
  * самая частая ситуация — следующей команде нужен результат предыдущей, но предыдущая ещё его не получила 
  * следующая команда записывает данные до того, как их читает предыдущая 
  * следующая команда записывает свои результаты раньше предыдущей из-за чего предыдущая потом может их перезаписать

@pause@

2. Конфликты по ресурсам — когда двум командам одновременно нужен эксклюзивный доступ к чему-либо

@pause@

3. Конфликты по управлению: следующая команда является условным переходом, но условие для него ещё не вычислено предыдущей командой
  * и даже не ясно, из какой ветви дальше выбирать команды

- - - - - -

## Решения

* Pipeline Stall — торможение команд на конвейере; в предельном случае может свести преимущества конвейеризации на нет
* Предсказание условных переходов — сбор статистики о переходах или подсказки от компилятора

- - - - - -

## Специфика RISC

У RISC простой формат машинного кода (пример — ARMv7):

<div style="text-align: center;">

![](images/08.ARMv7-code-format.png) <!--.element: style="width: 75%;" -->

</div>

* Простой блок выборки инструкций, простой конвейер
* Есть несколько «долгих» команд, которые выполняются асинхронно

@pause@

Многие RISC-семейства не отслеживают конфликты и не обрабатывают их!

- - - - - -

## Решения для RISC

* Переупорядочивание команд — конфликтующие команды размещаются «на безопасном расстоянии» друг от друга
* Торможение при помощи вставки «пузырька» (инструкция `nop`, no operation)

Для некоторых RISC-семейств всё это делает компилятор или программист!

@pause@

Некоторые RISC-семейства даже после безусловного перехода успевают «затянуть» на конвейер пару команд

- - - - - -

## Решения для CISC

Процессор полностью сам отвечает за корректное исполнение кода

* Обнаруживает конфликты
* Обрабатывает их

= = = = = =

# Параллельное выполнение независимых команд

- - - - - -

## Конвейер — это...

... очень хорошо. Но это всего лишь конвейер.

Хочется большего =)

- - - - - -

## Суперскалярность

<div style="text-align: center;">

![](images/08.superscalar_pipeline.svg) <!--.element: style="width: 40%;" -->

</div>

Иллюстрация для Classic RISC pipeline, хотя типичный современный RISC для этого простоват.

@pause@

В 1993 г. — Pentium I, Intel x86

* Два АЛУ
* Два конвейера, которые их «кормят»
* Компилятор старается располагать рядом независимые инструкции
  * Пример: запись на стек параметров функции при помощи команд `mov`, а не `push`, поскольку соседние `push` изменяют состояние стека $\Rightarrow$ зависимы

- - - - - -

## Суперскалярность: пример с mov vs push

С

```
f(0, 1, 5, 8);
```

Ассемблер x86 (32 бита)

```
Без оптимизации vs с оптимизацией
                   sub esp, 16
push 8             mov DWORD PTR [ebp-  8h], 8
push 5             mov DWORD PTR [ebp-  Bh], 5
push 1             mov DWORD PTR [ebp- 10h], 1
push 0             mov DWORD PTR [ebp- 14h], 0
call f             call f
```

Суперскалярный процессор может параллельно исполнить `mov` из примера

@pause@

**Суперскалярность** — возможность автоматического распараллеливания независимых близлежащих команд в машинном коде

- - - - - -

## VLIW

**Very Long Instruction Word** — подход к проектированию архитектур, подразумевающий явное распараллеливание независимых близлежащих команд в машинном языке


* Yale Multiflow, 1980-е
* Эльбрус 3, 1993
* Intel Itanium, 2001
* Современные DSP и GPU

Похоже на микропрограммирование: в одной машинной команде несколько инструкций для разных блоков процессора, которые задействуются параллельно. Не все блоки разные: м.б. несколько АЛУ, несколько математических сопроцессоров и т.д.

- - - - - -

## Внеочередное исполнение

**Внеочередное исполнение** (**Out of Order execution**) — способ выполнения машинных команд не в порядке следования, а в порядке готовности к исполнению

Впервые: Cray CDC 6600, 1963 г. При приблизительно тех же разрядности и тактовой частоте CDC 6600 был существенно быстрее БЭСМ-6, у которой был конвейер. Но и гораздо сложнее и дороже.

Идея: поток инструкций программы делится на:

1. Последовательность инструкций, к выполнению которых ещё не приступали
2. Инструкции, которыми «занимаются»
3. «Отработанные» инструкции

@pause@

Почти как конвейер, но интеллектуальнее: «текущий» фрагмент программы пропускается не через конвейер, а через «окно», в котором происходит гораздо больше всего.

- - - - - -

### Пример: Intel Core i7

1. Очередная команда разбивается на микрооперации (как в примере с Intel 80386)
2. Если фактически независимые микрооперации работают с одними и теми же регистрами, для них выделяются разные экземпляры регистров (стадия *переименования регистров*)
3. Микрооперации помещаются в Reorder Buffer и переупорядочиваются, в т.ч. с микрооперациями близлежащих команд 
4. Микрооперации поступают на 6 исполнительных блоков

Это делает процессорное ядро Intel OOO

- - - - - -

### Пример: Архитектура Intel OOO


<div style="text-align: center;">

![](images/08.Intel_OOO.png) <!--.element: style="width: 50%;" -->

</div>

- - - - - -

### Пример: Дальнейшее развитие Intel OOO

Впервые OOO применили в Pentium Pro d 1995 г.

* У Intel x86 достаточно сложный машинный код, из-за этого простаивали исполнительные блоки, а блок выборки за ними не успевал

@pause@

Идея: можно сделать два блока выборки и исполнять два потока на одном наборе исполнительных блоков

Запатентована в Sun Microsystems в 1994 г., впервые в серийных микропроцессорах реализована в Intel в 2002 г., технология названа Intel Hyperthreading

Одно ядро для программиста и ОС выглядит, как два

- - - - - -

### Пример: Intel HyperThreading

<div style="text-align: center;">

![](images/08.Intel_HT.png) <!--.element: style="width: 70%;" -->

</div>

Интересная популярная статья — [Путешествие через вычислительный конвейер процессора](https://habr.com/ru/post/182002/) (перевод)

- - - - - -

### А что же современные RISC?

Многие современные RISC процессоры, например, последние ARM, не только обнаруживают конфликты,
но и переупорядочивают инструкции, и выполняют прочие аналогичные оптимизации.

Причина?..

@pause@

В условиях параллельного выполнения программ на компилятор положиться уже не получится,
т.к. полная информация о последовательности операций доступна лишь во время выполнения.


= = = = = =

## Вопросы

1.	Расшифруйте термины CISC и RISC.
2.	Опишите преимущества CISC-архитектур.
3.	Назовите принципы RISC-архитектуры.
4.	Дайте определение конвейера. 
5.	Во сколько раз может максимально ускорить выполнение программы конвейер, выполняющий команды в 3 этапа?
6.	Назовите виды конфликтов конвейера.
7.	Как RISC-процессоры разрешают конфликты конвейера?
8.	Как CISC-процессоры разрешают конфликты конвейера?
9.	Дайте определение суперскалярной архитектуре.
10. Что такое VLIW?
11.	Что такое внеочередное исполнение машинных команд?
12. В чём идея технологии HyperThreading?

## Упражнения

* Скомпилируйте программу с условными переходами для RISC-процессора MIPS64 (можно воспользоваться специальными сервисами наподобие [Godbolt](https://godbolt.org/)). Найдите в получившемся ассемблере фрагменты, свидетельствующие о том, что процессор не обрабатывает конфликты
